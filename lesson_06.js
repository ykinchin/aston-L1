// 1)
// KISS (Keep It Simple, Stupid):
// Принцип KISS подразумевает, что решения должны быть максимально простыми. Это означает, что код должен быть понятным и легко читаемым.
// Избегайте излишней сложности и избыточности в коде. Простые решения обычно легче поддерживать и исправлять.

// DRY (Don't Repeat Yourself):
// Принцип DRY гласит, что каждая часть знания должна иметь единственное, непротиворечивое представление в системе.
// То есть избегайте повторения одного и того же кода в разных частях программы. Это помогает снизить сложность кода, облегчает его поддержку и изменения.

// YAGNI (You Aren't Gonna Need It):
// Принцип YAGNI предупреждает о том, что не следует добавлять функциональность в программу до тех пор, пока она действительно не понадобится.
// Избегайте излишества и переусложнения кода добавлением функций, которые не являются необходимыми на данный момент. Это помогает избежать лишней сложности и упростить код.

// Примеры антипаттернов включают в себя "Magic Numbers" (использование магических чисел в коде без объяснения их значения),
// "Spaghetti Code" (неструктурированный и запутанный код), "God Object" (класс или модуль, который знает и делает слишком много), и многие другие.

// 2)
// Локальное хранилище (LocalStorage), сеансовое хранилище (SessionStorage) и файлы cookie - это три основных механизма для хранения данных на стороне клиента в веб-браузерах.

// LocalStorage представляет собой простое хранилище ключ-значение, которое сохраняет данные на компьютере пользователя даже после закрытия браузера и перезагрузки компьютера.
// Данные в LocalStorage могут быть доступны из любой вкладки браузера и сохраняются на неограниченное время (пока пользователь не очистит их вручную или не удалит их через код).

// SessionStorage также является хранилищем ключ-значение, но данные, сохраненные в нем, существуют только в течение одной сессии браузера.
// Это означает, что данные будут удалены при закрытии вкладки или браузера.

// Файлы cookie - это небольшие текстовые файлы, которые хранятся на компьютере пользователя.
// Они могут использоваться для хранения информации, такой как идентификаторы сеансов, предпочтения пользователей и другие данные.
// Cookie могут быть настроены для срока действия, после которого они истекают, а также для определенных путей или доменов, на которых они действительны.

// 3)
//
// БЭМ (Блок-Элемент-Модификатор) - это методология именования классов в HTML и CSS, которая помогает создавать модульные, масштабируемые и повторно используемые компоненты в веб-проектах.
// Основные принципы БЭМ:

// Блок (Block):
// Блок представляет собой независимый компонент, который имеет семантическое значение и может быть использован повторно.
// Например, "header", "menu", "button" и т.д. В HTML блок обозначается классом вида .block.

// Элемент (Element):
// Элемент - это часть блока, которая не имеет смысла в отрыве от блока. Он является составной частью блока и используется только в контексте этого блока.
// Элемент обозначается классом вида .block__element.

// Модификатор (Modifier):
// Модификатор изменяет внешний вид или поведение блока или элемента. Модификаторы используются для создания вариаций блоков или элементов без изменения их базовой структуры.
// Модификатор обозначается классом вида .block--modifier или .block__element--modifier.

// 4)

// Паттерны функционального программирования - это шаблоны проектирования, которые основаны на принципах функционального программирования.
// Они помогают создавать чистый, модульный и выразительный код, используя функции высшего порядка, замыкания, чистые функции и иммутабельные структуры данных.
// Вот несколько популярных паттернов функционального программирования:

// Функции высшего порядка (Higher-Order Functions):
// Функции, которые могут принимать другие функции в качестве аргументов или возвращать функции в качестве результатов.
// Этот паттерн часто используется для создания абстракций и обобщений в коде.

// Чистые функции (Pure Functions):
// Функции, которые не имеют побочных эффектов и всегда возвращают одинаковый результат для одних и тех же входных данных.
// Они не изменяют состояние программы или внешние переменные, что делает их более предсказуемыми и проще для тестирования.

// Неизменяемость (Immutability):
// Использование неизменяемых структур данных, которые не могут быть изменены после создания.
// Это позволяет избежать нежелательных побочных эффектов и упрощает параллельное программирование.

// Рекурсия (Recursion):
// Процесс, при котором функция вызывает саму себя для решения задачи. Рекурсивные алгоритмы часто используются для обхода деревьев, поиска путей и других задач.

// Каррирование (Currying):
// Преобразование функции с несколькими аргументами в последовательность функций, каждая из которых принимает только один аргумент.
// Это позволяет создавать частично примененные функции и строить более сложные функции из простых.

// Композиция функций (Function Composition):
// Сочетание нескольких функций для создания новой функции. Это позволяет создавать цепочки операций, каждая из которых применяется к результату предыдущей.

// 5)
// Поточное позиционирование (Flow Layout):
// Это естественный способ размещения элементов на странице. Элементы располагаются друг за другом сверху вниз, начиная с верхнего левого угла контейнера.

// Абсолютное позиционирование (Absolute Positioning):
// Элементы с абсолютным позиционированием удаляются из потока документа и позиционируются относительно ближайшего позиционированного родительского элемента (если такой есть) или относительно окна браузера.
// Для этого используется свойство position: absolute;.

// Относительное позиционирование (Relative Positioning):
// Элементы с относительным позиционированием остаются в потоке документа, но их позиция может быть изменена с помощью свойств top, right, bottom и left.
// Позиционируются они относительно своего нормального местоположения. Для этого используется свойство position: relative;.

// Фиксированное позиционирование (Fixed Positioning):
// Элементы с фиксированным позиционированием позиционируются относительно окна браузера и остаются на месте при прокрутке страницы.
// Для этого используется свойство position: fixed;.

// Плавающие элементы (Floats):
// Плавающие элементы выведены из потока документа и позиционируются влево или вправо в пределах их родительского контейнера.
// Это часто используется для создания макетов с несколькими столбцами. Для этого используется свойство float.

// Flexbox Layout:
// Flexbox позволяет создавать гибкие макеты с помощью управления распределением и выравниванием элементов внутри контейнера.
// Это делается с помощью свойства display: flex; для родительского контейнера и различных свойств для управления распределением и выравниванием дочерних элементов.

// Grid Layout:
// CSS Grid Layout позволяет создавать сложные двумерные макеты с помощью сетки из строк и столбцов.
// Это делается с помощью свойства display: grid; для родительского контейнера и различных свойств для управления распределением и выравниванием элементов внутри сетки.

// 6)
// !important: Увеличивает приоритет стиля до максимального уровня.

// Встроенные стили (Inline styles): Имеют самый высокий приоритет и переопределяют все остальные стили.

// Идентификаторы (ID selectors): Увеличивает вес селектора на 100.

// Классы, псевдоклассы и атрибуты (Class selectors, Attribute selectors, Pseudo-classes): Каждый класс, атрибут или псевдокласс в селекторе увеличивает вес на 1.

// Универсальные селекторы (*), элементные селекторы (div, p, span и т.д.) и псевдоклассы (:hover, :nth-child() и т.д.): Вес - 0,0,1,0.

// Унаследованные стили (Inherited styles): Имеют самый низкий приоритет.
